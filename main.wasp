app honeycomb {
  wasp: {
    version: "^0.9.0"
  },
  title: "Honeycomb",
  auth: {
    userEntity: User,
    methods: {
      usernameAndPassword: {}
    },
    onAuthFailedRedirectTo: "/",
    onAuthSucceededRedirectTo: "/recipes"
  },
  dependencies: [
    ("@fortawesome/fontawesome-svg-core", "6.2.1"),
    ("@fortawesome/react-fontawesome", "0.2.0"),
    ("@fortawesome/free-solid-svg-icons", "6.2.1"),
    ("@fortawesome/free-regular-svg-icons", "6.2.1"),
    ("prop-types", "15.8.1"),
    ("uuid", "^9.0.0"),
    ("yup", "^0.32.11"),
    ("i18next", "^22.4.5"),
    ("react-i18next", "^12.1.1"),
    ("react-modal", "^3.16.1"),
  ],
  client: {
    setupFn: import setupClient from "@client/setup.js",
  },
}


route RootRoute { path: "/", to: LandingPage }
page LandingPage {
  component: import Main from "@client/LandingPage"
}

route LoginRoute { path: "/login", to: LoginPage }
page LoginPage {
  component: import Login from "@client/LoginPage"
}

route SignupRoute { path: "/signup", to: Signup }
page Signup {
  component: import Signup from "@client/SignupPage"
}

route RecipesRoute { path: "/recipes", to: Recipes }
page Recipes {
  component: import Recipes from "@client/Recipes"
}

route RecipeRoute { path: "/recipe/view/:slug", to: RecipePage }
page RecipePage {
  component: import Recipe from "@client/Recipe"
}

route RecipeEditRoute { path: "/recipe/edit", to: RecipeEdit }
page RecipeEdit {
  component: import RecipeEdit from "@client/RecipeEdit"
}

route AccountRoute { path: "/account", to: Account }
page Account {
  component: import Account from "@client/Account"
}

// requires auth
// args: none
// returns: { username: String }
query getUsername {
  fn: import { getUsername } from "@server/api/account.js",
  entities: [User]
}
// requires auth
// args: { username: string }
// returns nothing
action updateUsername {
  fn: import { updateUsername } from "@server/api/account.js",
  entities: [User]
}
// requires auth
// args: { email: string }
// returns nothing (fails if email is no longer unique)
action updateEmail {
  fn: import { updateEmail } from "@server/api/account.js",
  entities: [User]
}

// requires auth
// args: { tagSlugs?: [String], q?: String }
// returns: [{ slug: String, title: String, description: String, imageURI?: String, tagSlugs: String }]
query getRecipes {
  fn: import { getRecipes } from "@server/api/recipe.js",
  entities: [Recipe]
}

// requires auth
// args: none
// returns: [{ slug: String, tag: String, color: String }]
query getTags {
  fn: import { getTags } from "@server/api/recipe.js",
  entities: [RecipeTag]
}

// requires auth
// args: { slug: String }
// returns: Recipe (tagSlugs, ingredients list with id and text)
query getRecipe {
  fn: import { getRecipe } from "@server/api/recipe.js",
  entities: [Recipe]
}

// requires auth (user must own this recipe)
// args: { slug: String }
// returns: nothing
action deleteRecipe {
  fn: import { deleteRecipe } from "@server/api/recipe.js",
  entities: [Recipe, Ingredient]
}

// requires auth (user must own this recipe)
// args: Recipe (tagSlugs, ingredients list with id and text)
// returns: nothing
action updateRecipe {
  fn: import { updateRecipe } from "@server/api/recipe.js",
  entities: [Recipe, Ingredient, RecipeTag]
}

// requires auth
// args: Recipe (without recipe slug) (tagSlugs, ingredients list with id and text)
// returns: { slug: String }, the slug of the new recipe
action createRecipe {
  fn: import { createRecipe } from "@server/api/recipe.js",
  entities: [Recipe, Ingredient, RecipeTag]
}

entity User {=psl
  id Int @id @default(autoincrement()) // Required to be Int by usernameAndPassword method
  name String
  username String @unique // This is actually email, but usernameAndPassword method requires it be called username
  password String

  tags RecipeTag[]
  recipes Recipe[]
psl=}

entity Recipe {=psl
  id String @id @default(uuid())
  slug String @unique // Autogenerated slug (app-facing id/URL part)
  title String
  source String? // If present, can be used to automatically update the recipe (including from honeycomb:// URIs)
  description String
  time String // String to allow ranges
  servings String // String to allow different serving units
  imageURI String? // URI to image location
  public Boolean @default(false) // If true, recipe can be shared with others via a honeycomb:// URI

  ingredients Ingredient[]
  instructions String

  tags RecipeTag[]

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
psl=}

entity Ingredient {=psl
  id String @id @default(uuid())
  text String // In the future, possibly split into amount, unit, and text for scaling recipes

  recipe Recipe @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  recipeId String
psl=}

entity RecipeTag {=psl
  id String @id @default(uuid())
  slug String @unique // Autogenerated slug (app-facing id/URL part)
  tag String
  color String

  recipes Recipe[]

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
psl=}
